<!DOCTYPE html>

<html>

<head>
  <title>Onion's Life</title>
  <link rel="shortcut icon" type="image/png" href="sprites/onion.png" />
  <link rel="manifest" href="manifest.json" />
  <meta charset="utf-8">

  <style>
    * {
      margin: 0;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    body {
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      /* Safari */
      -ms-user-select: none;
      /* IE 10 and IE 11 */
      user-select: none;
      /* Standard syntax */
      touch-action: manipulation;
      /*sus stack 
      overflow code*/
      height: 110%;
      width: 100%;
      overflow: auto;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then(registrations => {
        for (let registration of registrations) {
          registration.unregister()
            .then(success => {
              if (success) {
                console.log('Service worker unregistered successfully');
              } else {
                console.log('Service worker unregistration failed');
              }
            })
            .catch(error => {
              console.error('Error during service worker unregistration:', error);
            });
        }
      }).catch(error => {
        console.error('Error retrieving service worker registrations:', error);
      });
    }

  </script>
  <script type="module">

    // import kaboom.js
    import kaboom from "https://unpkg.com/kaplay@3001.0.0-alpha.4/dist/kaboom.mjs"
    import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
    import registerTouchControls from "./scripts/touchCode.js";
    import loadAssets from "./scripts/assets.js";

    const SUPABASE_URL = 'https://ihrdqbqvoflutgbzhqqo.supabase.co'
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlocmRxYnF2b2ZsdXRnYnpocXFvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MTYwNDI1ODIsImV4cCI6MjAzMTYxODU4Mn0.d3Vac0lv5CicW-FF_NfZ7j3BAkaXEDLctg47V64S2NE'

    const supabase = createClient(SUPABASE_URL, SUPABASE_KEY)
    //generate random ID
    const userID = Math.floor(Math.random() * 1000000);
    var allUserIds = [];
    var otherOnions = [];
    var onions = [
      "onion", "onion-beach", "onion-blue", "onion-dark", "onion-gold",
      "onion-watermelon",
    ];
    const channel = supabase.channel('player_locations', {
      config: {
        presence: { userId: userID },
      },
    })
    const PLAYER_EVENT = 'player_moved'
    var trackingLevelId = 0;
    var myCoords = { x: 120, y: 40, level: trackingLevelId };
    var isDeathAnimEnabled = false;
    var multiplayerEnabled = true;
    var speedCap = 400; // raising this raises the max speed

    function subscribeToChannel() {
      // Subscribe to mouse events.
      // Our second parameter filters only for mouse events.
      channel
        .on(
          'broadcast',
          { event: PLAYER_EVENT },
          (event) => { receivedOnionPosition(event) }
        )
        .on(
          'broadcast',
          { event: 'new_player' },
          (event) => { receivedNewPlayer(event) }
        )
        .on(
          'broadcast',
          { event: 'player_died' },
          (event) => { receivedDeathMessage(event) }
        )
        .on(
          'broadcast',
          { event: 'move_levels' },
          (event) => { receivedMoveLevels(event) }
        )
        .on('presence', { event: 'join' }, ({ newPresences }) => {
          printOnions(newPresences)
        })
        .on('presence', { event: 'sync' }, () => {
          printOnions(channel.presenceState())

        })
        .subscribe(async (status) => {
          if (status === 'SUBSCRIBED') {
            await channel.track({ userId: userID, level: trackingLevelId, x: 120, y: 40 })
          }
        })
    }

    subscribeToChannel();

    function removeChannel() {
      const channel = supabase.removeChannel(channel);
    }

    //handle death event
    function receivedDeathMessage({ event, payload }) {
      const { userId } = payload
      if (userId !== userID) {
        // Check if we already have a sprite for this user.
        let onion = otherOnions.find(onion => onion.userId === userId)
        if (onion) {
          destroy(onion)
          otherOnions.splice(otherOnions.indexOf(onion), 1)
        }
        printOnions(channel.presenceState())
      }
    }

    //handle new players
    //this should also handle a received move levels inside it
    //it should send a move onion position event
    function receivedNewPlayer({ event, payload }) {
      receivedMoveLevels({ event, payload })
      sendOnionPosition(channel, userID, myCoords.x, myCoords.y, myCoords.level)
    }

    function removeOnionListFromScreen() {

      for (var i = 0; i < 20; i++) {
        add([
          text("", { size: 20 }),
          pos(canvasWidth - 400, 10 + (i * 20)),
          fixed(),
        ])
      }
    }


    //create a function that prints all onion users
    // this should add a number in the corner to display how many onions are on, and the uptime
    //this could include each user
    function printOnions(presences) {
      if (multiplayerEnabled) {
        //create a for loop that removes the previous onion text from screen
        //do it by inserting clear text in the for 20 onions in the same position
        removeOnionListFromScreen()
        var k = 0;
        for (const [userId, presence] of Object.entries(presences)) {
          if (presence.userId && presence.level) {
            if (allUserIds.find(user => user.userId === presence.userId)) {
              allUserIds.splice(allUserIds.indexOf(allUserIds.find(user => user.userId === presence.userId)), 1)
            }
            allUserIds.push({ userId: presence.userId, level: presence.level })
          }
          k++;
        }
        removeOnionListFromScreen()
        for (var i = 0; i < allUserIds.length; i++) {
          add([
            text(`Onion ${i + 1} (${allUserIds[i].userId}) - Level ${allUserIds[i].level}`, { size: 20 }),
            pos(canvasWidth - 400, 10 + (i * 20)),
            fixed(),
          ])
        }
      }
    }



    function receivedMoveLevels({ event, payload }) {
      const { userId, level } = payload;
      if (userId !== userID) {
        let onion = otherOnions.find(onion => onion.userId === userId);
        if (onion) {
          onion.level = level;
          // Check if the level matches the current player's level
          if (level !== trackingLevelId) {
            destroy(onion); // Remove sprite from view
            otherOnions.splice(otherOnions.indexOf(onion), 1); // Remove from array
          }
        }
      }
    }

    function receivedOnionPosition({ event, payload }) {

      const { userId, x, y, level } = payload;
      if (userId !== userID) {
        let onion = otherOnions.find(onion => onion.userId === userId);
        if (level === trackingLevelId) { // Ensure the onion is in the same level
          if (!onion) {
            onion = add([
              sprite("onion"),
              pos(x, y),
              doubleJump(),
              area(),
              body(),
              { userId, level }
            ]);
            otherOnions.push(onion);
          } else {
            onion.pos.x = x;
            onion.pos.y = y;

          }
        } else {
          if (onion) {
            destroy(onion); // Remove sprite from view
            otherOnions.splice(otherOnions.indexOf(onion), 1); // Remove from array
          }
        }
      }
    }




    // Helper function for sending our own mouse position.
    function sendOnionPosition(channel, userId, x, y, level) {
      if (multiplayerEnabled) {
        return channel.send({
          type: 'broadcast',
          event: PLAYER_EVENT,
          payload: { userId, x, y, level }
        })
      }
    }
    //what to do when the onion dies
    function sendDeathMessage(channel, userId) {
      //clear the other onions array
      otherOnions = [];
      if (multiplayerEnabled) {
        return channel.send({
          type: 'broadcast',
          event: 'player_died',
          payload: { userId }
        })
      }
    }

    function sendMoveLevels(channel, userId, level) {
      if (multiplayerEnabled) {
        return channel.send({
          type: 'broadcast',
          event: 'move_levels',
          payload: { userId, level }
        })
      }
    }


    // send a death message when the user leaves the page
    window.addEventListener('beforeunload', () => {
      sendDeathMessage(channel, userID)
      printOnions(channel.presenceState())
    })




    let canvasWidth = document.documentElement.clientWidth;
    let canvasHeight = document.documentElement.clientHeight;
    let deviceMode = null;
    let heightStretch = 0;
    if ((window.matchMedia('(display-mode: fullscreen)').matches || window.navigator.fullscreen) && navigator.userAgent.includes('Android')) {
      // Code for PWA running on Android
      deviceMode = "Android";
      heightStretch = 75;
    } else if ((window.matchMedia('(display-mode: fullscreen)').matches || window.navigator.fullscreen) && navigator.userAgent.includes('CrOS')) {
      // Code for PWA running on Chrome OS
      deviceMode = "ChromeOS";
    } else {
      // Code for non-PWA behavior or other platforms
      deviceMode = "Other";
    }

    import { LEVELS, levelConf } from './scripts/levels.js';
    import optimizeLevel from "./scripts/levelOptimizer.js";
    //var scale = 1;
    //if (canvasWidth < 800){
    //scale = .5;
    //} 
    //initializing
    kaboom({
      background: [153, 204, 255],
      //scale: scale,
      width: canvasWidth,
      font: "apl386",
      height: canvasHeight + heightStretch,
      //crisp: true,
    })





    // load assets
    loadAssets();


    //convert the layers to kaboom js 3000
    const bg = add([
      fixed(),
      z(200),
    ])
    const obj = add([
      fixed(),
      z(400),
    ])
    const game = add([
      fixed(),
      z(0),
    ])
    const ui = add([
      fixed(),
      z(800),
    ])
    const title = add([
      fixed(),
      z(700),
    ])


    //if(savedId != null){
    //  savedId = 0;
    //} else {
    //  highestId = getData(savedId);
    //}
    //}
    var rEnabled = true
    var loops = 0;
    var lvlWidth = 0;
    var jumpCount = 0;
    var subX = 0;
    var subY = 0;
    // Set a cookie
    function setCookie(name, value, days) {
      let expires = "";
      if (days) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        expires = "; expires=" + date.toUTCString();
      }
      document.cookie = name + "=" + value + expires + "; path=/";
    }

    // Get a cookie value
    function getCookie(name) {
      const cookies = document.cookie.split("; ");
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].split("=");
        if (cookie[0] === name) {
          return cookie[1];
        }
      }
      return null;
    }
    var slctId = 0;
    var onionId = 0;
    // Set a high score cookie
    function setHighLevel(score) {
      const existingHighLevel = getCookie("highLevel");
      if (!existingHighLevel || parseInt(score) > parseInt(existingHighLevel)) {
        setCookie("highLevel", score, 700);
      }
    }

    // Get the high score
    function getHighLevel() {
      if (getCookie("highLevel") > LEVELS.length - 1) {
        return LEVELS.length - 1;
      } else {
        return getCookie("highLevel");

      }
    }
    var first = true;
    scene("game", ({ levelId, coins } = {
      jumpCount: 0,
      levelId: 0,
      coins: 0,
      levelName: "Intro",
    }) => {
      setGravity(1300)
      if (first) {
        levelId = slctId;
        first = false;
        trackingLevelId = slctId;
        channel.track({ userId: userID, level: levelId })
      }
      if (!first) {
        levelId = slctId;
        trackingLevelId = slctId;
        channel.track({ userId: userID, level: levelId })

        highestId = levelId > highestId ? levelId : highestId;

      }
      if (levelId > highestId) {
        highestId = levelId;
      }

      //if(levelId > savedId) {
      //  setData(savedId, levelId)
      //}


      addLevel(optimizeLevel(LEVELS[levelId ?? 0]), levelConf)
      function sendNewPlayer() {
        // send a new player event
        if (multiplayerEnabled) {
          return channel.send({
            type: 'broadcast',
            event: 'new_player',
            payload: { userId: userID, x: 120, y: 40, level: levelId }
          })
        }
      }
      removeOnionListFromScreen()
      if (multiplayerEnabled) {
        printOnions(channel.presenceState())
      }
      sendNewPlayer()


      const music = play("OverworldlyFoe", {
        volume: 1,
        loop: true
      })
      // add a character to screen
      const onion = add([
        // list of components
        doubleJump(),
        sprite(onions[onionId]),
        pos(120, 40),
        area(),
        body({ maxVelocity: 1000 }),
      ])

      var levelNames = ["Intro", "Classic ~ 1", "Flying For Coins ~ 2",
        "Bouncy House ~ 3", "Booby Trap ~ 4", "Staircase of Doom ~ 5",
        "Boucin' Around ~ 6", "Look Out Below ~ 7", "Whoop de doo ~ 8",
        "Healthy Hurdles ~ 9", "Onion Can Fly ~ 10", "Free Fallin' ~ 11",
        "Da Brick Wall ~ 12", "Leap O' Faith ~ 13", "Descending Tomfoolery ~ 14",
        "Now this is Hard ~ 15", "DON'T GET SPIKED ~ 16", "Platform Chaos ~ 17",
        "Enter the Secret Lair ~ 18", "Secret Lair ~ 19", "Rollercoaster ~ 20",
        "Onion's got HOPS ~ 21", "Cruisin' for a Bruisin' ~ 22", "Mount Scallion ~ 23",
        "DROP ~ 24", "Tower of Pain ~ 25", "Tricky timing ~ 26", "Insane Precision ~ 27",
        "It's Not That Simple ~ 28", "It's a long drop ~ 29", "Into the Abyss ~ 30",
        "Enter the Labyrinth ~ 31", "The Labyrinth ~ 32", "Onion's Demise ~ 33",
        "The Heist ~ 34", "We're Just Getting Started ~ 35",
        "Box of Terror ~ 36", "THE CHALLENGE ~ 37", "Zigzaggy ~ 38", "GET DOWN ~ 39",
        "fR3EkKy dE3eKkKkkyYyY ~ 40", "Dodging and weaving ~ 41", "THE TUBE ~ 42", "Electric Boogaloo ~ 43","Caleb go crazy" "Perilous Path (ChatGPT Trial 1) ~ 44"
      ];

      var notRColor = 255 * (levelId / levelNames.length);
      console.log(levelNames[levelId]);
      add([
        text(levelNames[levelId], { size: 64 }),
        color(255, 255 - notRColor, 255 - notRColor),
        fixed(),
        pos(40, 40),
      ])

      //that music annoys me
      onKeyPress('s', () => {
        if (music.paused) {
          music.play()
        } else {
          music.stop()
        }
      })
      //music.detune(-2000)
      // Function to apply random effects to the music
      function applyRandomEffects() {
        // Randomly detune the music
        music.detune = Math.floor(Math.random() * 6001) - 3000; // Adjust the range as desired

        // Randomly change the music's speed
        music.speed = Math.random() * 2 + 0.5; // Adjust the range as desired

      }

      // Function to continuously apply changing effects
      function continuouslyChangeEffects() {
        setInterval(() => {
          if (music && music.paused) {
            applyRandomEffects();
          }
        }, 2000); // Adjust the interval duration as desired (in milliseconds)
      }

      // Event listener for the "c" key press
      onKeyPress("c", () => {
        if (music && music.paused) {
          applyRandomEffects();
        } else {
          applyRandomEffects();
          continuouslyChangeEffects();
        }
      });

      //movement or controls
      onKeyPress('p', () => {
        music.stop()
        onKeyPress('z', () => {
          music.stop()
          if (levelId + 1 < LEVELS.length) {
            go("game", {
              levelId: levelId + 1,
              coins: coins,

            })
            levelId = levelId + 1
            trackingLevelId = levelId;
            slctId = levelId
            setHighLevel(levelId)
            channel.track({ userId: userID, level: levelId })
          } else {
            destroy(onion),
              play("win")
            add([
              text("You Win!"),
              color(0, 255, 0),
              pos(onion.pos),
              anchor("center"),
            ])
            setHighLevel(levelId)

          }
        })

      })
      onKeyPress("b", () => {
        go("title");
        music.paused = true;
      })
      onKeyDown('left', () => {
        moveOnion(true, 400)
      })
      onKeyDown('a', () => {
        moveOnion(true, 400)
      })


      onKeyDown('right', () => {
        moveOnion(false, 400)
      });
      onKeyDown('d', () => {
        moveOnion(false, 400)
      });

      function moveOnion(invert, distance) {
        onion.move(!invert ? distance : -distance, 0)
        sendOnionPosition(channel, userID, onion.pos.x, onion.pos.y, levelId);
        myCoords = { x: onion.pos.x, y: onion.pos.y, level: levelId };
      }

      registerTouchControls(onion, moveOnion, levelId, setHighLevel, rEnabled, music, applyRandomEffects, continuouslyChangeEffects, jumpCount);



      if (levelId != 32) {
        onKeyPress("up", () => {
          play("jump")
          onion.doubleJump()
          sendOnionPosition(channel, userID, onion.pos.x, onion.pos.y, levelId);
          myCoords = { x: onion.pos.x, y: onion.pos.y, level: levelId };
        })
        onKeyPress("w", () => {
          play("jump")
          onion.doubleJump()
          sendOnionPosition(channel, userID, onion.pos.x, onion.pos.y, levelId);
          myCoords = { x: onion.pos.x, y: onion.pos.y, level: levelId };
        })
        onKeyPress("space", () => {
          play("jump")
          onion.doubleJump()
          sendOnionPosition(channel, userID, onion.pos.x, onion.pos.y, levelId);
          myCoords = { x: onion.pos.x, y: onion.pos.y, level: levelId };
        })
      } else if (levelId == 32) {
        onKeyPress("up", () => {
          play("jump")
          onion.jump()
          sendOnionPosition(channel, userID, onion.pos.x, onion.pos.y, levelId);
          myCoords = { x: onion.pos.x, y: onion.pos.y, level: levelId };
        })
        onKeyPress("w", () => {
          play("jump")
          onion.jump()
          sendOnionPosition(channel, userID, onion.pos.x, onion.pos.y, levelId);
          myCoords = { x: onion.pos.x, y: onion.pos.y, level: levelId };
        })
        onKeyPress("space", () => {
          play("jump")
          onion.jump()
          sendOnionPosition(channel, userID, onion.pos.x, onion.pos.y, levelId);
          myCoords = { x: onion.pos.x, y: onion.pos.y, level: levelId };
        })
      }


      onKeyPress("f", (c) => {
        setFullscreen(!isFullscreen())
      })

      //devkey
      /*onKeyDown('q', () => {

         onion.jump()

        })*/

      //scrolling
      // camera follows player
      onion.onUpdate(() => {
        camPos(onion.pos)
        sendOnionPosition(channel, userID, onion.pos.x, onion.pos.y, levelId);
        myCoords = { x: onion.pos.x, y: onion.pos.y, level: levelId };
      })

      //spike code
      onion.onCollide("danger", (danger) => {
        die()

      })
      onion.onCollide("enemy", (a, col) => {
        // if it's not from the top, die
        if (col.isBottom()) {
          shake()
          onion.jump(1200)
          destroy(col.target)

        }
        else if (!col.isBottom()) {
          die()
        }
      })
      /*onion.onCollide("ground",(ground)=>{
      play("jump")

      //})
    */
      //write code so that if the d button is clicked, death animation is disabled
      onKeyPress("d", () => {
        isDeathAnimEnabled = !isDeathAnimEnabled;
      })
      var shownYouLose = false
      function die() {
        if (!isTouchscreen() && isDeathAnimEnabled) {
          loops = 0;
          const sprites = [
            "onion",
            "heart",
            "coin",
            "onion-watermelon",
            "onion-beach",
            "onion-watermelon2",
            "onion-blue",
            "onion-gold",
            "onion-dark"
          ]

          sprites.forEach((spr) => {
            loadSprite(spr, `sprites/${spr}.png`)
          })

          loop(0.1, () => {
            if (loops < 5) {
              const item = add([
                pos(onion.pos),
                sprite(choose(sprites)),
                anchor("center"),
                scale(rand(0.25, 0.5)),
                area(),
                body({ solid: false, }),
                lifespan(0.75, { fade: 0.5 }),
                move(choose([LEFT, RIGHT]), rand(60, 240)),
                offscreen({ hidden: true }),
              ])

            }
            loops++;
          })
        }

        // Compose particle properties with components
        destroy(onion)
        shake();
        music.paused = !music.paused;
        play("death", { volume: 0.2 })
        if (shownYouLose == false) {
          shownYouLose = true
          add([
            text("You Lose", { size: 48 }),
            pos(onion.pos),
            anchor("center"),
            color(255, 0, 0),
          ])
          // Can someone figure out how to get the pos of this correct
          /*
          const respawn = add([
            sprite("keyboardR"),
            pos(onion.pos),
            anchor("center"),
            fixed(),
          ])
          respawn.add([
            text("Respawn"),
            fixed(),
            pos(75, 13),
          ])*/
        }
        setHighLevel(levelId);
        sendDeathMessage(channel, userID);
      }
      //write a function to dtermine if there is are clouds in the camera view
      //if there are not, spawn a cloud
      function checkClouds() {
        var camPosition = camPos();
        var clouds = get("cloud");
        var cloudPositions = clouds.map(cloud => cloud.pos);
        var cloudInCamera = cloudPositions.filter(cloudPos => {
          return cloudPos.x > camPosition.x - 100 && cloudPos.x < camPosition.x + width() + 100
        })
        if (cloudInCamera.length <= 2) {
          spawnCloud()
        }

      }
      var clouds = []
      function spawnCloud() {
        const dir = choose([LEFT, RIGHT]);
        var cloud = add([
          sprite("cloud", { flipX: dir === LEFT }),
          move(dir, rand(20, 60)),
          offscreen({ destroy: true }),
          pos(rand(-20 + onion.pos.x, width() + onion.pos.x + 300), rand(-20, 480)),
          anchor("top"),
          area(),
          z(-50),
          "cloud",
        ]);
        clouds.push(cloud);

        if (clouds.length > 3) {
          destroy(clouds[0]);  // Just destroy the cloud object
          clouds.shift();      // Remove the first element from the array after it's destroyed
        }
      }

      //spawn 3 clouds to start
      for (let i = 0; i < 3; i++) {
        spawnCloud()
      }
      setInterval(spawnCloud, 15000)
      setInterval(checkClouds, 1000)



      const score = add([
        text("Score: 0"),
        pos(40, 100),
        { value: 0 },
        fixed(),
      ])
      onion.onCollide("key", (key) => {
        //write a for loop to get all doors and remove them
        get("door", { recursive: true, liveUpdate: true }).forEach((door) => {
          destroy(door)
        })

        destroy(key);
        shake();
      })
      onion.onCollide("coin", (coin) => {
        play("score")
        score.value += 1
        score.text = "Score:" + score.value
        destroy(coin)

      })

      //define layers


      //portal code

      onion.onCollide("portal", () => {
        music.paused = !music.paused;
        play("portal")
        sendMoveLevels(channel, userID, levelId + 1)
        trackingLevelId = levelId + 1;
        if (levelId + 1 < LEVELS.length) {
          go("game", {
            levelId: levelId + 1,
            coins: coins,

          })
          levelId = levelId + 1
          trackingLevelId = levelId;
          slctId = levelId
          setHighLevel(levelId)
        } else {
          destroy(onion),
            play("win")
          add([
            text("You Win!"),
            color(0, 255, 0),
            pos(onion.pos),
          ])
          setHighLevel(levelId)
        }
      })
      onion.onCollide("arg", () => {
        music.paused = !music.paused;
        go("game", {
          levelId: -1,
          coins: coins,
        })
      })
      //jumpy code
      onion.onCollide("jumpy", () => {
        play("jumpy")
        onion.jump(1200)
        //shake()
      })
      onion.onCollideUpdate("right", () => {
        moveOnion(false, 300)
      })
      onion.onCollideUpdate("left", () => {
        moveOnion(true, 300)

      })


      //Set a variable to move in update in onCollide, change the variable to not move in the ending collision
      onion.onCollide("stop", () => {
        onion.move(0, 0)
      })

      //add code that opens a text box if the key l is pressed
      //the text box allows the user to manually import level code
      onKeyPress("l", () => {
        const levelCode = prompt("Enter level code:");
        if (levelCode) {
          const level = levelCode.split("\n");
          addLevel(level, levelConf);
          //update level names to put this at the end
          levelNames.push("Custom Level");
          //update the LEVELS array
          LEVELS.push(level);
          go("game", {
            levelId: levelNames.length - 1,
            coins: 0,
          });
        }
      });

      //if(rEnabled == true){
      onKeyPress("r", () => {
        music.stop()
        go("game", {
          levelId: levelId,
        });
        //caleb is cool
      });
      //}


    });

    scene("title", () => {
      if (parseInt(getHighLevel()) > 0) {
        highestId = parseInt(getHighLevel());
        slctId = parseInt(getHighLevel());
        first = false;
      } else {
        slctId = 0;
        first = true;
      }
      onKeyPress("s", () => {
        go("customization");
      })

      onKeyPress("c", () => {
        go("credits");
      })

      onKeyPress("m", () => {
        go("multiplayer");
      })

      add([
        text("Onion's Life", { size: 120, align: "center" }),
        color(0, 255, 0),
        fixed(),
        anchor("center"),
        pos(width() / 2, height() * 0.10),
      ])

      const startBtn = add([
        sprite("startbtn"),
        "start",
        fixed(),
        area(),
        anchor("center"),
        pos(width() / 2, height() * 0.9),
      ])

      const lvlSelect = add([
        sprite("lvlSelect"),
        "lvlSelect",
        fixed(),
        area(),
        anchor("center"),
        pos(width() / 2 + 300, height() * 0.9),
      ])

      const skinsBtn = add([
        sprite("skinsBtn"),
        "skins",
        fixed(),
        area(),
        anchor("center"),
        pos(width() / 2 - 300, height() * 0.9),
      ])

      onClick("skins", () => {
        go("skins");
      })

      startBtn.add([
        text("PLAY", { size: 64 }),
        fixed(),
        anchor("center"),
      ])

      onClick("start", () => {
        go("game");
      })

      onKeyPress("space", () => {
        go("game");
      })

      onClick("skins", () => {
        go("skins");
      })

      onClick("lvlSelect", () => {
        go("select");
      })
      //registers touch 
      if (isTouchscreen()) {
        onTouchStart((id, pos) => {
          if (startBtn.hasPoint(pos)) {
            go("game");
          }
          if (lvlSelect.hasPoint(pos)) {
            go("select");
          }
          if (skinsBtn.hasPoint(pos)) {
            go("skins");
          }
        })
      }


      add([
        // list of components
        sprite("bigonion"),
        pos(width() / 2 - 115, height() / 2 - 126),
      ])

      onKeyPress('p', () => {
        go("piracy");
      })

      onKeyPress('q', () => {
        onKeyPress('m', () => {
          onKeyPress('p', () => {
            levelId = levelNames.length;
            trackingLevelId = levelId;
            slctId = levelId;
            setHighLevel(levelId);
            channel.track({ userId: userID, level: levelId })
          })
        })
      })

    })

    scene("select", () => {

      if (slctId == highestId) {
        add([
          sprite("lockedarrowr"),
          pos(width() * 0.65 - 32, height() / 2 - 64),
        ])
        add([
          sprite("lockedarrowr"),
          pos(width() * 0.8 - 32, height() / 2 - 64),
        ])
      }

      onKeyPress('b', () => {
        go("title");
      })

      const levelButton = add([
        // list of components
        sprite("lvlbtn"),
        "btn",
        pos(width() / 2 - 128, height() / 2 - 128),
        area(),

      ])

      const backKeybind = add([
        sprite("keyboardB"),
        pos(width() * 0.02, height() * 0.9)
      ])

      backKeybind.add([
        text("Back"),
        pos(75, 13),
      ])

      if (slctId > 9) {
        lvlWidth = 250;
        subX = 120;
        subY = 90;
      }
      if (slctId < 10) {
        lvlWidth = 100;
        subX = 55;
        subY = 290;
      }

      add([
        text(slctId, {
          size: 150,
          width: lvlWidth,
          height: 180,
        }),
        pos(width() / 2 - subX, height() / 2 - subY),
      ])
      //touchscreen
      const leftArrow = add([
        sprite("arrowl"),
        "l",

        area({ scale: 2, }),
        pos(width() * 0.35 - 32, height() / 2 - 64),
      ])
      if (slctId < highestId) {
        var rightArrow = add([
          sprite("arrowr"),
          "r",
          area({ scale: 2, }),
          pos(width() * 0.65 - 32, height() / 2 - 64),
        ])
      }
      const superLeftArrow = add([
        sprite("arrowl"),
        "sl",
        area({ scale: 2, }),
        pos(width() * 0.2 - 32, height() / 2 - 64),
      ])
      if (slctId < highestId) {
        var superRightArrow = add([
          sprite("arrowr"),
          "sr",
          area({ scale: 2, }),
          pos(width() * 0.8 - 32, height() / 2 - 64),
        ])
      }
      if (isTouchscreen()) {
        onTouchStart((id, pos) => {
          if (slctId < highestId) {
            var rightArrow = add([
              sprite("arrowr"),
              "r",
              area({ scale: 2, }),
            ])
            rightArrow.pos = vec2(width() * 0.7 - 32, height() / 2 - 64);
            if (rightArrow.hasPoint(pos)) {
              if (slctId < LEVELS.length - 1) {
                if (slctId < highestId) {
                  slctId++;
                  go("select");
                }
              }
            }
          }
          if (leftArrow.hasPoint(pos)) {
            if (slctId > 0) {
              slctId--;
              go("select");
            }
          }
          if (levelButton.hasPoint(pos)) {
            go("game");
          }

        })

      }

      onClick("sr", () => {
        if (slctId + 10 <= LEVELS.length - 1) {
          if (slctId + 10 <= highestId) {
            slctId += 10;
          } else {
            slctId = highestId;
          }
          go("select");
        } else {
          slctId = highestId;
          go("select");
        }
      })
      onClick("sl", () => {
        if (slctId - 10 >= 0) {
          slctId -= 10;
        } else {
          slctId = 0;
        }
        go("select");
      })

      onClick("r", () => {
        if (slctId < LEVELS.length - 1) {
          if (slctId < highestId) {
            slctId++;
            go("select");
          }
        }
      })
      onClick("b", () => {
        go("title");
      });
      onClick("l", () => {
        if (slctId > 0) {
          slctId--;
          go("select");
        }
      })

      onClick("btn", () => {
        go("game");
      })


      add([
        text("Level Select", { size: 64 }),
        fixed(),
        pos(40, 40),
      ])
    })

    scene("credits", () => {
      onKeyPress('b', () => {
        go("title");
      })

      add([
        text("Credits"),
        pos(80, height() * 0.05),
      ])

      add([
        text("Neal - Lead Developer"),
        pos(80, height() * 0.35),
      ])
      add([
        text("Romeo - Lead Level Designer"),
        pos(80, height() * 0.45),
      ])
      add([
        text("Caleb - Lead UI Designer"),
        pos(80, height() * 0.55),
      ])
      add([
        text("Eli - Lead App Developer"),
        pos(80, height() * 0.65),
      ])


    })

    scene("skins", () => {
      onKeyPress('b', () => {
        go("title");
      })

      add([
        text("Customization", { size: 64 }),
        color(255, 255, 255),
        fixed(),
        pos(40, 40),
      ])

      const backKeybind = add([
        sprite("keyboardB"),
        pos(width() * 0.02, height() * 0.9)
      ])

      backKeybind.add([
        text("Back"),
        pos(75, 13),
      ])

      const skinSelectBtn = add([
        // list of components
        sprite("lvlbtn"),
        "btn",
        pos(width() / 2 - 128, height() / 2 - 128),
        area(),

      ])
      const onionSelect = add([
        // list of components
        sprite(onions[onionId]),
        "btn",
        pos(width() / 2 - 38, height() / 2 - 50),
        area(),

      ])

      const leftArrow = add([
        sprite("arrowl"),
        "l",

        area({ scale: 2, }),
        pos(width() * 0.3 - 32, height() / 2 - 64),
      ])

      var rightArrow = add([
        sprite("arrowr"),
        "r",
        area({ scale: 2, }),
        pos(width() * 0.7 - 32, height() / 2 - 64),
      ])

      onClick("r", () => {
        if (onionId == (onions.length - 1)) {
          onionId = 0;
        } else {
          onionId++;
        }
        go("skins");
      })
      onClick("l", () => {
        if (onionId == 0) {
          onionId = (onions.length - 1);
        } else {
          onionId--;
        }
        go("skins");
      })

      onClick("btn", () => {
        go("game");
      })

    })

    scene("multiplayer", () => {
      onKeyPress('b', () => {
        go("title");
      })

      add([
        text("Multiplayer", { size: 120 }),
        color(255, 255, 255),
        fixed(),
        pos(width() / 2 - 395, height() * 0.05),
      ])

      const onOffBtn = add([
        // list of components
        sprite("lvlbtn"),
        "btn",
        pos(width() / 2 - 128, height() / 2 - 128),
        area(),

      ])
      if (multiplayerEnabled) {
        const onOffText = add([
          // list of components
          text("ON", { size: 100 }),
          "txt",
          pos(width() / 2 - 56, height() / 2 - 34),
          area(),

        ])
      } else {
        const onOffText = add([
          // list of components
          text("OFF", { size: 100 }),
          "txt",
          pos(width() / 2 - 86, height() / 2 - 34),
          area(),
        ])
      }

      const leftArrow = add([
        sprite("arrowl"),
        "l",

        area({ scale: 2, }),
        pos(width() * 0.3 - 32, height() / 2 - 64),
      ])

      var rightArrow = add([
        sprite("arrowr"),
        "r",
        area({ scale: 2, }),
        pos(width() * 0.7 - 32, height() / 2 - 64),
      ])

      onClick("r", () => {
        multiplayerEnabled = !multiplayerEnabled;
        go("multiplayer");
      })
      onClick("l", () => {
        multiplayerEnabled = !multiplayerEnabled;
        go("multiplayer");
      })
    })
    var highestId = 0;
    // scene("piracy", () => {
    //   add([
    //     // list of components
    //     sprite("nopiracy"),
    //     pos(width() / 2 - 115, height() / 2 + 50),
    //   ])

    //   add([
    //     text("Onion doesn't like", {size: 120}),
    //     layer("title"),
    //     color(255, 255, 255),
    //     fixed(),
    //     pos(width() / 2 - 651, height() * 0.10),
    //   ])
    //   add([
    //     text("pirates.", {size: 120}),
    //     layer("title"),
    //     color(255, 0, 0),
    //     fixed(),
    //     pos(width() / 2 - 275, height() * 0.30),
    //   ])
    //   onKeyPress("h", () => {
    //     onKeyPress("q", () => {
    //       go("title");
    //     })
    //   })
    // })
    /*
    scene("dj", () => {
      const music = play("OverworldlyFoe", {
        volume: 1,
        loop: true
      })
      music.play()
      const wheelSize = 100; // Size of the control wheels
      const wheelSpacing = 50; // Spacing between the wheels
      const wheelCenterY = height() / 2; // Y position for all wheels
      const wheelSpeed = 0.1; // Speed of wheel rotation

      const wheels = [
        { name: "Volume", value: 0, min: 0, max: 1, step: 0.1 },
        { name: "Speed", value: 1, min: 0.5, max: 2, step: 0.1 },
        { name: "Detune", value: 0, min: -1200, max: 1200, step: 100 },
      ];

      const wheelSprites = [];

      // Create the control wheels
      wheels.forEach((wheel, index) => {
        const wheelSprite = add([
          sprite("dj"),
          area(),
          pos((index + 1) * (wheelSize + wheelSpacing), wheelCenterY),
          anchor("center"),
          rotate(0),
          wheel,
        ]);
        wheelSprites.push(wheelSprite);
      });

      // Function to modify the sound based on the wheel values
      function modifySound() {
        const volume = wheelSprites[0].value;
        const speed = wheelSprites[1].value;
        const detune = wheelSprites[2].value;

        // Apply the modifications to the sound
        music.volume(volume);
        music.speed(speed);
        music.detune(detune);
      }

      // Update the sound modification on each frame
      action(() => {
        modifySound();
      });

      // Mouse movement and click events to control the wheels
      let wheelIndex = 0; // Index of the active wheel

      onMouseMove(() => {
        wheelIndex = Math.floor(mousePos().x / (wheelSize + wheelSpacing));
      });

      onMousePress(() => {
        const activeWheel = wheelSprites[wheelIndex];
        const scrollDelta = mousePos().y - activeWheel.pos.y;

        // Update the wheel value based on the scroll direction and step
        const { value, min, max, step } = activeWheel;

        if (scrollDelta > 0) {
          activeWheel.value = Math.min(value + step, max);
        } else if (scrollDelta < 0) {
          activeWheel.value = Math.max(value - step, min);
        }
      });
    }) 
    */
    // if ((window.matchMedia('(display-mode: fullscreen)').matches || window.navigator.fullscreen) || (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone)) {
    go("title");
    // }

  </script>

</body>

</html>
